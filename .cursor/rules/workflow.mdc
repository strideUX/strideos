---
alwaysApply: false
---
# Doc-Driven Workflow Rules

## Documentation Check (ALWAYS FIRST)
Before any coding work, check for docs/ folder:

**If docs/ folder exists:**
- Proceed with full doc-driven workflow below
- Reference all relevant docs for context

**If docs/ folder does NOT exist:**
1. **Stop and ask user**: "I don't see a docs/ folder. Would you like me to:"
   - "A) Set up the complete doc-driven structure (specs, architecture, design, stack, tasks)"
   - "B) Proceed with exploratory coding (we can add docs later)"
2. **If user chooses A**: Create complete docs/ structure with templates
3. **If user chooses B**: Continue coding but periodically suggest docs for larger features

## Doc-Driven Workflow (when docs/ exists)

### Before Starting Any Work:
1. Read docs/tasks.md to understand current focus and session status
2. Review relevant docs (specs, architecture, design, stack) for context
3. Check the "Current Focus" and "Session Status" sections in tasks.md

### During Development:
1. Reference the docs for all implementation decisions
2. Update docs when making significant changes or discoveries
3. Move tasks through workflow states as you complete them
4. Document any architecture or design decisions during implementation
5. Follow stack.md guidelines for technology-specific patterns

### Task Management in docs/tasks.md:
- Use workflow states: Backlog ‚Üí In Progress ‚Üí Review ‚Üí Done
- Include acceptance criteria for each task
- Track estimates and actual time when relevant
- Link related tasks and dependencies
- Document implementation notes and decisions

## Task Completion & Progress Tracking

### During Development
- **Check off individual tasks** as they are completed within each feature
- **Update feature progress** percentage when significant milestones are reached
- **Move features** between sections (In Progress ‚Üí Completed) when all tasks are done

### Task Checking Protocol
When a task is completed:
1. Mark the task with `[x]` in the appropriate feature section
2. Update any progress indicators or percentages
3. Note completion in session summary
4. Move to next logical task in sequence

### Feature Completion Protocol
When all tasks in a feature are complete:
1. Move entire feature from "üìã Up Next" to "‚úÖ Completed Features"
2. Update "Current Sprint" section with next priority
3. Update session status with accomplishment
4. Reference next feature in dependency chain

### Bug Discovery & Resolution Protocol

#### When Bugs Are Found in "Completed" Features
1. **Stop forward progress** - Don't start new features until bugs are resolved
2. **Create bug tracking** in current session status:
   ```markdown
   **Current Blockers:**
   - Bug in Feature X: [brief description]
   - Status: Investigating/Fixing/Testing
   ```
3. **Reopen the feature** - Move from "‚úÖ Completed" back to "üîÑ In Progress"
4. **Add bug fix tasks** to the feature:
   ```markdown
   **Bug Fix Tasks:**
   - [ ] Investigate root cause of [issue]
   - [ ] Implement fix for [specific problem]
   - [ ] Test fix thoroughly
   - [ ] Verify no regression in other areas
   ```

#### Quality Gates Before Moving Forward
Before starting any new feature, verify:
- [ ] Previous feature works as specified in acceptance criteria
- [ ] All tasks are genuinely complete (not just checked off)
- [ ] Basic testing confirms functionality
- [ ] No known bugs or regressions

#### Bug Priority Levels
**Critical (Block everything):** Core functionality broken, authentication issues, data loss
**High (Fix before new features):** Important features not working, user experience issues  
**Medium (Fix in current sprint):** Minor functionality issues, edge cases
**Low (Backlog):** Polish items, nice-to-have improvements

#### Testing Checkpoints
After completing each foundation feature (1-5):
- [ ] Manually test the completed functionality
- [ ] Verify acceptance criteria are met
- [ ] Check for obvious edge cases or errors
- [ ] Confirm integration with previous features works

## Scope Changes & Enhancement Protocol

### Before Adding Any New Functionality
Always evaluate against existing docs/tasks.md:

1. **Check if feature exists and is completed** ‚Üí Enhancement/Extension
2. **Check if feature exists but not done** ‚Üí Update existing feature
3. **Feature doesn't exist** ‚Üí Add new feature

### Scope Change Evaluation Process

#### When Implementation Changes Our Approach
1. **Pause development** and assess impact on remaining tasks
2. **Review docs/tasks.md** for affected features
3. **Update task descriptions, acceptance criteria, and estimates**
4. **Reorder dependencies** if the change affects feature sequence
5. **Update architecture.md** if technical approach changes
6. **Document the scope change** in session notes with rationale

#### Enhancement vs. New Feature Decision Tree
**Is this functionality already listed in tasks.md?**
- **YES + Status: Completed** ‚Üí Create Enhancement
- **YES + Status: Not Complete** ‚Üí Update Existing Feature  
- **NO** ‚Üí Create New Feature

### Enhancement Handling
When building on completed features:
```markdown
### Feature X Enhancement: [Enhancement Name]
**Base Feature:** Feature X (Completed)
**Enhancement Goal:** [What new capability this adds]
**Priority:** [High/Medium/Low]
**Dependencies:** Feature X must remain stable

**Acceptance Criteria:**
- [ ] Original Feature X functionality unchanged
- [ ] New enhancement integrates seamlessly
- [ ] No regression in existing behavior

## "Wrap Session" Command:
When user says "wrap session", "end session", or similar, immediately perform:

1. **Review Current Work:**
   - Assess progress on active tasks in docs/tasks.md
   - Note any incomplete work or decisions made
   - Identify any code needing cleanup or documentation

2. **Update Task Progress:**
   - Move completed tasks to "Done" with timestamp
   - Update percentage completion on in-progress tasks
   - Update time spent vs estimates
   - Note any subtasks completed

3. **Update Session Status in docs/tasks.md:**
   - Current timestamp and session duration
   - Summary of accomplishments this session
   - Current focus for next session
   - Clear next steps and priorities
   - Document any blockers or decisions needed
   - **Update quality status and any discovered bugs**

4. **Code Cleanup (if needed):**
   - Remove temporary console.logs or debug code
   - Add missing comments for complex logic
   - Ensure code follows project standards

5. **Documentation Updates:**
   - Update specs.md if requirements clarified
   - Update architecture.md if technical decisions made
   - Update design.md if UI patterns established
   - Update stack.md if new tech patterns discovered

6. **Session Archive:**
   - Add session to "Session Notes Archive"
   - Include duration, focus, accomplishments
   - Note important discoveries or decisions
   - **Record any bugs found or quality issues**

**Response Template:**
"üîÑ Wrapping up session...
‚úÖ [Major accomplishments]
üìù Updated task progress: [specific updates]
üêõ [Any bugs found or quality issues]
‚è≠Ô∏è Next session focus: [clear priority]  
üìã [Blockers/notes]
‚ú® Session complete!"

## Documentation Updates:
- Update specs.md when requirements change or clarify
- Update architecture.md when making technical decisions
- Update design.md when establishing UI patterns
- Update stack.md when discovering new patterns or best practices
- Keep docs current with implementation reality

## Exploratory Coding Mode (when docs/ doesn't exist):
- Focus on rapid experimentation and learning
- Suggest creating docs when patterns emerge
- Offer to create docs structure for larger features
- Periodically ask if user wants to formalize with documentation